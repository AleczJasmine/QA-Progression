**June 30, 2025 Notes**

**Roles in the Software Development Team**

- Requirements Engineers/Business Analyst/Product Owner
- SRS - outlines the complete and precise definition of a software product's intended behavior and performance
- BRD - focuses on the business need
    - BRD,SRS, User story
    - As a tester your job is to sometimes **write an acceptance criteria**
    - Your job as a tester is to review these BRD, find ambiguities, inconsistencies, any incompleteness
- UI/UX Designer
    - Figma. Wireframe
    - Test the design as a tester
    - Check if the requirements follow the design given
- Front-end, Back-end and Mobile Developers
    - Development
    - Front-end = test; Backend = test; Front-end+Backend = **integration testing**
- Project Manager & Scrum Master(for agile teams)
- Software Tester

**How software is developed - Software development lifecycle models**

1. Sequential Development
- Analysis -> Design -> Implementation->Testing
- Does not go back
- Waterfall model - testing is not early, not recommended
- V-Model (created due to drawbacks of waterfall)

VModel Testing:

- Requirements = Acceptance Testing (Creation of test analysis and design)
- Specification = System Testing (Creation of test scenarios and test cases)
- Architectural = Integration Testing (Creation of test integration cases)
- Detailed Design = Unit Testing (Creation of test driven development)
- Test Levels Meaning:
    - Unit Testing - dev; cares about how the software is developed
    - Acceptance Testing - what the user needs
    - Integration Testing - dev
    - System Testing - software tester
1. Agile Software Development
- Is not sequential
- Continuous Feedback
- Agile Manifesto = 4 values, 12 principles

2.1 Incremental and Iterative Development

- Incremental - each part is unusable as a whole
    - System is not usable not until the whole system is finished
- Iterative - each part can be usable
    - MVP - Minimum Valuable Product
- Scrum Process
    - Agile is a way of thinking
    - An approach to apply agile principles
    - User stories - written functionalities
    - Scrum is an iterative model
- Difference Between Sequential, Iterative and Incremental Development
    - Sequential
        - Fixed Requirements
        - Cannot change the requirements
    - Agile
        - Fixed Time
        - Fixed Effort
        - Estimated Requirements
        - Use “cone of uncertainty”

**July 1, 2025**

**Basic Concepts of Software Testing**

What is Testing?

- Testing things to work as expected to avoid loss of money, time, business reputation, etc.
- Assess the quality, reduce the risk
- Not only test execution, it is a **process** where execution is only a part of it

Static and Dynamic Testing

- Both are the responsibility of the tester
1. Dynamic Testing
- Type of processing
- Providing input to the system, then the system processes it to give an output.
- Compare the output to the expected output
1. Static Testing
- Does not process
- Not providing input, not expecting output
- Reviewing the design, code, and documents is an example
- White-box testing: reviewing the code in order to test its functionality
- Early testing since it is easier to test it statistically

Validation and Verification

1. Validation
- Am I building the right product?
- Will the application satisfy the user’s needs?
- Thinking of other aspects of the system for the user
- Does not have to follow a written requirement
1. Verification
- Is the application inline with the requirements?
- Am I building the product right?

Objectives of Software Testing

1. Work-product evaluation
- Work products: documents to create the final product
1. Requirements Fulfillment
2. Building Confidence
- Our application is free of defects
1. Finding Defects
2. Preventing Defects
- Make sure the defect does not happen in the first place
- Reviewing the requirements, doing early testing
1. Providing Information to Stakeholders
- The software tester is usually the one who provides information if the software is ready to be released or not
1. Reduce Risk
2. Compliance with Laws
3. Objectives may vary

Testing and Debugging

1. Testing
- Static and Dynamic Testing
- Finding defects for reporting
- Writing a defect report
1. Debugging
- Removing the cause of the defect/failure
- Development activity
1. Confirmation Testing
- Are the defects fixed?
- Repeating the steps that caused the defect

Test Process

- About dynamic testing
- Plan->Design->Execution
- Plan: Analysis, Strategy, Plan, Tools
- Design: Test cases, scripts, scenarios, env
- Execution: Test report, defect tracking, defect analysis and report

Test Process Activities

1. Test Planning
- Test Plan, deliverables needed
- Written by test manager or test leader
1. Test Monitoring & Control
- Compare what happened in the project and in the plan
- Comparing the schedules from the test plan
- Control is the plan to go back to the test plan
- Responsibilities of the test manager or test leader
- Creates the test progress report
- Are continuous activities
1. Test Analysis
- Analyze the BRD
- Create the test scenarios
- Identify what we are going to test, usually written in a simple sentence
1. Test Design
- Create the test cases
- How are we going to test those functionalities/scenarios?
1. Test Implementation
- Are we ready to begin execution?
- Where will we execute the test cases?
1. Test Execution
- Run our test cases and test scenarios
1. Test Completion
- Create the reports and hand over to the team
- Test Completion Report

Test Levels

- Are test activities that are organized and managed together
- Each test level is an instance of the process
- Test levels are related to other activities within the software development lifecycle
1. Component Testing/Unit Testing
- Testing components that are separately testable
1. Integration Testing
- Testing the interactions between the components
1. Component Integration
- Testing the components
1. System Integration
- Testing the two systems (backend, frontend)

-   Component Testing -> Component Integration Testing -> System Testing -> System Integration Testing

- Component Integration Testing are usually done by devs

-   System Integration Testing is done by tester

3. System Testing

- Usually called “end-to-end” testing
- Main responsibility of the tester
- The test environment should ideally correspond to the final target or production environment
- Main goal: Find defects

4. Acceptance Testing

- UAT
- Focuses on the end users
- Main goal: Should be as bug free as possible
1. Alpha Testing
- Invite potential users to test the system in our own company
1. Beta Testing
- Invite potential users to test the system in their own homes

Testing Types

1. Functional Testing
- Tests what the system does
- Answered with (Y/N)
1. Non-functional Testing
- Tests how the system performs
- Usually measured as a range
- Usability, performance, security
- Hard to answer with (Y/N)
- Is the app quick enough? How much time does it respond?
1. Black-box Testing
- Testing without knowing the internal structure of the system
- Providing input to the system and wait for the output
- Near to the requirements of the user
1. White-box Testing
- Testing with the knowledge of the internal structure of the system
- How the system performs my functionality
- Testing the request, the API request that was sent and what is the request received
1. Dynamic Testing
- Testing that includes executing the software
1. Static Testing
- Testing that does not include executing the software
1. Retesting (Confirmation Testing)
- Testing after debugging to ensure defects are fixed
1. Regression Testing
- Testing unchanged areas to ensure they are not affected by changes
- Try to use automation as much as possible
1. Smoke Testing
- Testing main functionalities and simple tests
- Allows to save time

What’s Next? Talking about the ISTQB

- Go to [ISTQB.org](http://istqb.org/)
- Go to the Certified Tester Foundation Level and study their syllabus and try their exams
- Go for the ISTQB Foundation Level Certified Tester
- Agile Tester: Simple certificate
- Specialist Certificates: go to any specialist tester certificate based on your speciality
- Core Certificates: Need a lot of experience in the field

**Test Scenario Writing**

Test Scenario

- Reviewing the requirements to prepare creating test scenarios for them
- Is defined as any functionality that can be tested
- Also called test condition or test possibility
- Think about the scenarios the user would do in your application

How to Create a Test Scenario

1. Create the Requirement Document
2. Isolate every requirement and identify what possible user actions that need to be tested for it
3. Enumerate Test Scenarios that covers the possible features
4. Create **Traceability Matrix** to ensure that every requirement is mapped to a test scenario
5. Get the scenarios reviewed by a supervisor
6. Map the priorities of the test scenarios

Tools to help in creating Test Scenarios

1. Google
2. ChatGPT

**July 2, 2025**

Setting Up Trello

- A team management tool
- Atlassian is a company that has a lot of tools (Trello and Jira)

Key Takeaway from Learning this course:

1. Knowing how to create test scenarios using Trello Tool
2. You should know your audience, who is the app built for?

E.g. if it is an international level app, test the test fields if it can accept russian letters, arabic letters, etc

1. Valid scenarios are actually more tough to create than valid scenarios
2. Any field when you provide invalid data in it, whether it is leaving the field empty, providing too short value, providing invalid input.All other fields should be filled with valid data.

**Reason:** If you filled two fields with invalid data and the application crashed, you will not be able to find out what field caused the crash

1. Verify vs Validate:

### Verify = "Did we build it right?"

- You check if the form, buttons, or fields work the way they should.
- Example: You verify if the name field only accepts 50 characters.
- **Check** the form or input rules
- Is the system built right?

### Validate = "Did we build the right thing?"

- You test if the system works for the user's needs or real-world rules.
- Example: You validate if the password is strong or if the user is old enough to sign up.
- **Test** real user data and rules
- Does it make sense for real users?

**July 3, 2025**

1. High level scenarios = more broad, low level scenarios = more specific
- Ex. Validate ALL redirections in the page = high level
1. Manual Testers should be able to generate many scenarios and execute them
2. Usability Suggestion - suggesting a better way to implement a functionality
3. Test analysis is writing test scenarios, test design is writing test cases

**July 4, 2025**

**Black-box Testing Techniques**

- Applied in system testing or acceptance testing
1. Equivalence Partitioning - divides the system into smaller partitions and each partition has a similar behavior
2. Boundary Value Analysis - same with equivalence but we focus on values on the boundaries
3. Decision Table Testing
4. State Transition Testing - going through different systems, login -> homefeed
5. Pairwise Testing - combination of different inputs (e.g search functionality)
- Just provide input and wait for output
- Also called “Behavioral-based Testing”

Equivalence Partitioning

[](https://lh7-rt.googleusercontent.com/docsz/AD_4nXdPf1TnTta0qBsMG75phy_gfzemr0jbup4EGYrGPNFHpg83aOUaqrX_8Uq0zQLyZsKL7b0_obgwwgfK0BqJBvCyhSPGdXJo3q154dyBjJ9U14CuSX60bo1QGc8bA8iplCY7TUXRGA?key=iE4UZac5u5rdOXpBxf1K1g)

- Equivalence partitioning is basically testing the system if it is properly doing what its needed to be done in a specific part of the process/partition
- Covering each partition in the system with one test case
- Identify the partitions, then for each partition, test each one time per day
- **Basically, You test just one value from each group instead of testing everything — because the system is expected to handle all values in that group the same.**
- A form only accepts numbers from **1 to 100**. You choose to test the values 0, 50, and 101.
- → This is a correct use of equivalence partitioning.

## Notes:

**July 7, 2025**

**Equivalence Partitioning examples**

- Identify your partitions first

Example: Grading system of  F to A

- equivalence partitioning divides the input domain into distinct **partitions that represent different classes of input based on expected behavior**, rather than equal sizes.

**Boundary-Value Analysis**

- An extension of equivalence partitioning
- Is more complex
- You should use boundary-value analysis when you have a clear start and end of each partition
- 
    
    [](https://lh7-rt.googleusercontent.com/docsz/AD_4nXfdSPF-ULFD9fDT34LZUkZdWzWQI73y3r5Z0y1vIcR770Px9bbMrqXY14ntZP3cYakoeC9TAVBrVYIpTR0hFofxvE2eAm-YxSiYr7Csf9FGDjObjJeGKY6-r3X9BkG910roGJyVdg?key=iE4UZac5u5rdOXpBxf1K1g)
    
- Basically boundary-value analysis is testing the boundary values and not the values in between them
- 2 Boundary value analysis = the last value from the first partition and the first value from the second partition
- An example of boundary value analysis = Testing the first invalid value and first valid value example is age is less than 13, you will test between 12 years old and 13 years old.
- 

**Notes about EP and BVA**

- Each value belongs to only one partition
- EV and BVA can be applied to both input or output values
- Two types of partitions: valid and invalid partitions
- **EVC** = # of partitions covered by TCs / total number of partitions
- **BVAC = # of boundaries covered by TCs/ total number of boundaries**
    - Each boundary = 2 values

**Decision Table Testing**

- Different combinations of conditions result in different outcomes
- 
    
    [](https://lh7-rt.googleusercontent.com/docsz/AD_4nXeBwRJHjU1MTIkkpkLSYB9tuowGm4XPewAMyoNDQsop6x0nfsFJxCpHniwawZjOlk-tnJAGIzO_nMGXo9k36iTjwPS1CvOm0ieshcr8ZQ6No1JipEpWn14tM4OKuX9nlrNt-5N5?key=iE4UZac5u5rdOXpBxf1K1g)
    
- **Formula: no. of table rules = 2^n**
    - N = no. of questions/conditions
    - 2 = yes/no questions
    - Table rules = columns
- 
    
    [](https://lh7-rt.googleusercontent.com/docsz/AD_4nXfSIGIvtHuKT0A8KNbQxrsYh37kx7-IDdTwwuhFunyxtECIGD51dcnRMWeuTkuX5xAdeapUKh-kLH0u9TSNt0lNmqWp8K1uM5VxdW93sIHLOhliKb0tc2Wg19NiHoxgbtT2yjDe?key=iE4UZac5u5rdOXpBxf1K1g)
    

**State-Transition Testing**

- Having states and transitions in your system
- A **state** is a place in which your system can rest
- 
    
    [](https://lh7-rt.googleusercontent.com/docsz/AD_4nXd5B-eiPlvWuRIaiP2bdz7D8ekqdA2mxmpBo1OP67OimOgqv6Z4dEVr4eb0cvNX8LI8MNjB8hYvwV5-n2ZcaaxLNHoL_56eB5dkmOM2Jj1IdzMvDc36M0_P0i_EOdMBFXNB18euug?key=iE4UZac5u5rdOXpBxf1K1g)
    
- 
    
    [](https://lh7-rt.googleusercontent.com/docsz/AD_4nXe1dNtNA50IMa6l-aU2Hyc7tIaSHb1mAgf_LvSq8wQRurth03pLZ3euAzq_hoTXwmBW0geaIiuZ3VJSmGLzZXxzH2OKWjem3026PhIzVNRkoxnfjUfTue1meLlzPY96jFGmNeETZg?key=iE4UZac5u5rdOXpBxf1K1g)
    
- 
    
    [](https://lh7-rt.googleusercontent.com/docsz/AD_4nXfb5O5vuezURcwlwinosJYJC6tk1xSTR_gqiG12GffeRu-VwlIDiHcRyBxhBBwWymrwlesRdNhQpN9BwIfLautX7Htm8avCTQpU8byLV86KhVk_qo0CnxdaZZMfSYhxDDGYv1qw-w?key=iE4UZac5u5rdOXpBxf1K1g)
    
- Dead state = no transition is going out of it, or cannot continue working on the system

**Pairwise Testing**

- Applied in some specific cases inside your websites
- Ex: You have 3 fields but each field has more than one option
- In pairwise testing, each pair of values should appear with each other at least in one test case
- testing **every possible combination of pairs** of input values. Instead of testing all combinations
- Use pairwise pict online
- If you need to test all the pairs just multiply it by each others pairs (example: 3 bread x 3 cheese = 9 combinations)
- Pairwise testing is simply making sure at least one pair appears in the test cases
- 
    
    [](https://lh7-rt.googleusercontent.com/docsz/AD_4nXdwq6-McOpqOXxtoqnEzrt7C6VIxarort4OKcY_j-j0q9aMP6LdjuSjq5CvEtWDlWM_8EyznH2U2ow4FpBNFvoXD5NF0Tp5Fi1p0yZk8ejhensVu7xRi8nyZ-yeQpw-TPXLqHzbyA?key=iE4UZac5u5rdOXpBxf1K1g)
    
- Example: 4.0 and up and all levels
- So instead of 80 test cases, using pairwise you can only have up until 22 test cases

**July 9, 2025**

**Test Case Writing**

- One of the most important skills of a software tester
- A **test case** is a set of preconditions, inputs, actions and expected results developed based on the test conditions
- A **test condition/test scenario** (functionality, etc) is only one line where as the test case is one document
- Example: the one I do in google sheets

**Parts of a Test Case:**

1. Test Case Title: Verify login with valid username and password
2. Precondition: User is already registered using valid credentials
3. Test Steps: steps that need to be executed to run the test case
4. Expected result
5. Test Scenario (Test Suite): Where the test case belong to: example: Login
    1. A group where the related test cases belong to
6. Test Environment: Where Im going to test this application (example: Windows 11 - Chrome - Wifi Samsung)
7. Actual Result: only fill it up after executing the test case
8. Status: Not Started, Pass, Fail, Blocked/Skipped
